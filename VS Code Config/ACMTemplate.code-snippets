{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"template": {
		"scope": "cpp",
		"prefix": "template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#ifndef ONLINE_JUDGE",
			"#include \"include/debug.cpp\"",
			"#else",
			"#define debug(...) (void)(0)",
			"#endif",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"using pii = pair<int, int>;",
			"void sol(){",
			"\t",
			"}",
			"int main(){",
			"\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"\tint t = 1;",
			"\t// cin >> t;",
			"\twhile (t--){",
			"\t\tsol();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "C++ template for competitive programming with debug macro"
	},
	"templatec": {
		"scope": "c",
		"prefix": "template",
		"body": [
			"#include <stdio.h>",
			"int main(){",
			"\treturn 0;",
			"}"
		],
		"description": "C template with basic structure"
	},
	"binpow": {
		"scope": "cpp",
		"prefix": "binpow",
		"body": [
			"ll binpow(ll a, ll b){",
			"\tif(b == 0){",
			"\t\treturn 1;",
			"\t}",
			"\tif(b % 2 == 0){",
			"\t\tll res = binpow(a, b / 2);",
			"\t\treturn (res * res);",
			"\t}else{",
			"\t\tll res = binpow(a, b - 1);",
			"\t\treturn a * res;",
			"\t}",
			"}"
		],
		"description": "Binary pow"
	},	
	"dsu": {
		"scope": "cpp",
		"prefix": "DSU",
		"body": [
			"struct DSU {",
			"\tvector<int> fa;",
			"\tint n;",
			"\tDSU(int size): n(size), fa(size) {",
			"\t\tfor(int i = 0; i < n; i++){",
			"\t\t\tfa[i] = i;",
			"\t\t}",
			"\t};",
			"",
			"\tint find(int x) {",
			"\t\treturn fa[x] == x ? x : fa[x] = find(fa[x]);",
			"\t}",
			"",
			"\tvoid merge(int x, int y) {",
			"\t\tfa[find(x)] = fa[find(y)];",
			"\t}",
			"",
			"\tbool query(int x, int y){",
			"\t\treturn find(x) == find(y);",
			"\t}",
			"",
			"\tint root(void){",
			"\t\tint res = 0;",
			"\t\tfor(int i = 0; i < n; i++){",
			"\t\t\tif(fa[i] == i){",
			"\t\t\t\tres++;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		],
		"description": "Disjoint Set Union (DSU) data structure"
	},
	"gcd": {
		"scope": "cpp",
		"prefix": "gcd",
		"body": [
			"int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}",
		],
		"description": "Greatest Common Divisor (GCD)"
	},
	"lcm": {
		"scope": "cpp",
		"prefix": "lcm",
		"body": [
			"int lcm(int a, int b){return (a * b) / gcd(a, b);}"
		],
		"description": "Least Common Multiple (LCM)"
	},
	"fenwick": {
		"scope": "cpp",
		"prefix": "Fenwick",
		"body": [
			"template<typename T> struct Fenwick{",
			"\tint n;",
			"\tvector<T> tr;",
			"",
			"\tFenwick(int size) : n(size), tr(size + 1){}",
			"",
			"\tint lowbit(int x){",
			"\t\treturn x & -x;",
			"\t}",
			"",
			"\tvoid update(int idx, T val){",
			"\t\tfor(int i = idx; i <= n; i += lowbit(i)){",
			"\t\t\ttr[i] += val;",
			"\t\t}",
			"\t}",
			"",
			"\tT query(int idx){",
			"\t\tT res = T();",
			"\t\tfor(int i = idx; i > 0; i -= lowbit(i)){",
			"\t\t\tres += tr[i];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"",
			"\tT query(int l, int r){",
			"\t\treturn query(r) - query(l - 1);",
			"\t}",
			"};",
			"using BIT = Fenwick<int>;"
		],
		"description": "Fenwick Tree (Binary Indexed Tree)"
	},
	"sieve": {
		"scope": "cpp",
		"prefix": "Sieve",
		"body": [
			"struct Sieve{",
			"\tint n;",
			"\tvector<bool> p;",
			"",
			"\tSieve(int n): n(n), p(n){",
			"\t\tfor(int i = 0; i < n; i++){",
			"\t\t\tp[i] = true;",
			"\t\t}",
			"\t\tp[0] = p[1] = false;",
			"\t\tfor(int i = 2; i * i < n; i++){",
			"\t\t\tif(p[i]){",
			"\t\t\t\tfor(int j = i * i; j < n; j += i){",
			"\t\t\t\t\tp[j] = false;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t};",
			"};"
		],
		"description": "Sieve of Eratosthenes for prime number generation"
	},
	"lca": {
		"scope": "cpp",
		"prefix": "LCA",
		"body": [
			"struct LCA{",
			"\tint LOG;",
			"\tvector<vector<int>> fa;", 
			"\tvector<int> dep;",
			"\tvector<vector<int>> g;",
			"",
			"\tLCA(vector<vector<int>> g): g(g), LOG(log2(g.size()) + 1){",
			"\t\tint n = g.size();",
			"\t\tfa = vector<vector<int>>(n, vector<int>(LOG, -1));",
			"\t\tdep = vector<int>(n);",
			"\t\tdfs(0, -1);",
			"\t}",
			"",
			"\tvoid dfs(int node, int from){",
			"\t\tfa[node][0] = from;",
			"\t\tfor(int i = 1; i < LOG; i++){",
			"\t\t\tif(fa[node][i - 1] != -1){",
			"\t\t\t\tfa[node][i] = fa[fa[node][i - 1]][i - 1];",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor(auto next : g[node]){",
			"\t\t\tif(next == from){",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tdep[next] = dep[node] + 1;",
			"\t\t\tdfs(next, node);",
			"\t\t}",
			"\t}",
			"",
			"\tint query(int u, int v){",
			"\t\tif(dep[u] < dep[v]){",
			"\t\t\tswap(u, v);",
			"\t\t}",
			"",
			"\t\tfor(int i = LOG - 1; i >= 0; i--){",
			"\t\t\tif(dep[u] - (1 << i) >= dep[v]){",
			"\t\t\t\tu = fa[u][i];",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif(u == v){",
			"\t\t\treturn u;",
			"\t\t}",
			"",
			"\t\tfor(int i = LOG - 1; i >= 0; i--){",
			"\t\t\tif(fa[u][i] != fa[v][i]){",
			"\t\t\t\tu = fa[u][i];",
			"\t\t\t\tv = fa[v][i];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn fa[u][0];",
			"\t}",
			"};",
		],
		"description": "Lowest Common Ancestor (LCA) using Binary Lifting"
	}	
}