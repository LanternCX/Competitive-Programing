**题目：**看病要排队

**OJ平台判题结果：**   AC

### 一、问题描述

看病要排队这个是地球人都知道的常识。
不过经过细心的 0068 的观察，他发现了医院里排队还是有讲究的。0068 所去的医院有三个医生（汗，这么少）同时看病。而看病的人病情有轻重，所以不能根据简单的先来先服务的原则。所以医院对每种病情规定了 10 种不同的优先级。级别为 10 的优先权最高，级别为 1 的优先权最低。医生在看病时，则会在他的队伍里面选择一个优先权最高的人进行诊治。如果遇到两个优先权一样的病人的话，则选择最早来排队的病人。

现在就请你帮助医院模拟这个看病过程。

**输入格式**：

输入数据包含多组测试，请处理到文件结束。
每组数据第一行有一个正整数 N (0 < N < 2000) 表示发生事件的数目。
接下来有 N 行分别表示发生的事件。
一共有两种事件：
1:"IN A B", 表示有一个拥有优先级B的病人要求医生A诊治。(0 < A <= 3, 0 < B <= 10)
2:"OUT A", 表示医生 A 进行了一次诊治，诊治完毕后，病人出院。(0 < A <= 3)

**输出格式**：

对于每个"OUT A"事件，请在一行里面输出被诊治人的编号 ID 。如果该事件时无病人需要诊治，则输出"EMPTY"。
诊治人的编号 ID 的定义为：在一组测试中，"IN A B"事件发生第K次时，进来的病人 ID 即为 K。从 1 开始编号。

**输入样例**：

```
7
IN 1 1
IN 1 2
OUT 1
OUT 2
IN 2 1
OUT 2
OUT 1
2
IN 1 1
OUT 1
```

**输出样例**：

```
2
EMPTY
3
1
1
```

### 二、数据结构定义与分析

本次实验中定义了以下 1 个结构体，（包含 3 个成员整形变量。）:

- `node`:

  - `id`：病人编号

  - `a`：病人要求的医生编号 A

  - `b`：病人优先级 B

本次实验中定义了以下 1 个数据结构:

一个由三个`priority_queue`组成的`vector`，其中`priority_queue`维护`node`结构体的顺序，其初始化内容如下：

```c++
vector<priority_queue<node, vector<node>, greater<node>>> pq(3);
```

本次实验中定义了以下 5 个变量:

- `n`：发生事件的数目（整形变量）
- `id`：维护的病人编号（整形变量）
- `op`：当前事件进行的操作（字符串变量）
- `a`：病人要求的医生（整形变量）
- `b`：病人优先级（整形变量）

### 三、算法分析

模拟题，由于数据量较小其实直接维护三个`vector`然后在每次`OUT`的时候`sort`也可以

注意到每次都取优先级最大的病人，可以使用优先队列维护优先级最高的病人，代码实现起来较为方便，而且时间复杂度较低

需要注意的是，三个医生的病人编号是共享的，也就是说编号并不是每个医生分别计算

### 四、测试用例设计及测试结果

#### 1. 样例测试：

**输入：**

```
7
IN 1 1
IN 1 2
OUT 1
OUT 2
IN 2 1
OUT 2
OUT 1
2
IN 1 1
OUT 1
```

**预期输出：**

```
2
EMPTY
3
1
1
```

**实际输出：**



#### 2. 所有医生都有病人

**输入：**

```
9
IN 1 5
IN 2 3
IN 3 10
OUT 3
OUT 1
OUT 2
```

**预期输出：**

```
3
1
2
```

**实际输出：**



#### 3. 优先级相同，按先来顺序

```
5
IN 1 5
IN 1 5
OUT 1
OUT 1
```

**预期输出：**

```
1
2
```

**实际输出：**



#### 4. 多个医生交替操作

**输入：**

```
10
IN 1 3
IN 2 5
IN 1 4
IN 3 2
OUT 2
OUT 1
OUT 1
OUT 3
```

**预期输出：**

```
2
3
1
4
```

**实际输出：**



#### 5. 所有医生 OUT 时没有病人

**输入：**

```
3
OUT 1
OUT 2
OUT 3
```

**预期输出：**

```
EMPTY
EMPTY
EMPTY
```

**实际输出：**



从以上测试当中可以检验出程序的完备性

### 五、存在问题及可能原因

1. 审题问题

  问题：病人编号等的模拟错误

  原因：审题错误导致误认为每个医生的病人队列独立编号

2. 优先队列初始化问题

  问题：优先队列的比较规则错误

  原因：优先队列中结构体的比较需要重载运算符，在实现重载运算符逻辑的时候需要注意符合题意

3. 没有注意到有多组测试用例

  问题：没有注意到有多组测试用例

  原因：没有使用 `while(cin >> n)` 判断是否输入已经结束

### 六、附源代码以及代码相应注释

```c++
// 万能头文件
#include <bits/stdc++.h>
using namespace std;
// 病人结构体
struct node{
    // 病人编号
    int id;
    // 要求的医生 A
    int a;
    // 病人优先级 B
    int b;
    // 重载运算符 > ，提供给优先队列进行比较
	bool operator > (const node &x) const {
        // 若优先权相同则按照病人编号比较
		if(b == x.b){
			return id > x.id;
		}
        // 优先权不同优先权高的病人先进行诊治
		return b < x.b;
	} 
};
void slove(){
    // 发生事件的数目
	int n;
    // 通过判断是否到达 EOF 判断输入是否结束
	while(cin >> n){
        // 初始化优先队列，由于最多只有 3 个医生可以直接初始化优先队列大小为 3
		vector<priority_queue<node, vector<node>, greater<node>>> pq(3);
		// 初始化病人编号为 0
        int id = 0;
		for(int i = 0; i < n; i++){
            // 读取当前事件的操作
			string op;
			cin >> op;
            // 如果是 IN 事件
			if(op == "IN"){
                // 读入要求的医生和优先级
				int a, b;
				cin >> a >> b;
                // 对齐到 0 开头数组
				a--;
                // 更新编号
				id++;
                // 将病人结构体推入优先队列
				pq[a].push({id, a, b});
			}
            // 如果是 OUT 事件
			if(op == "OUT"){
                // 读入医生编号
				int a;
				cin >> a;
                // 对齐到 0 开头数组
				a--;
                // 如果当前医生的排队列表为空则打印 EMPTY 并执行下一个循环
				if(pq[a].empty()){
					cout << "EMPTY\n";
					continue;
				}
                // 打印需要诊治的病人编号
				cout << pq[a].top().id << '\n';
                // 将病人移除出优先队列
				pq[a].pop();
			}
		}
	}
}
int main(){
    // 关闭同步流，快读快写
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        slove();
    }
    return 0;
}
```

### 七、实验总结及建议

模拟题。在实现模拟题的题干中的算法时，需要先对题目进行充分的理解以及构建清晰的思路，再对算法进行实现。模拟题的算法一般来说较为复杂，不能在读完题后直接开始进行代码的书写，需要先确定思路，否则会造成代码逻辑混乱，且对调试造成不必要的困难。实际上，模拟题的难度并不算大，考验的是选手的细心与耐心。在实现模拟题的时候，一定不能急躁，需要耐心阅读题干并实现所需的算法。同时，在实现模拟算法的时候，可以考虑多种实现方式，并使用实现最为方便的一种减小自身程序出错的概率。