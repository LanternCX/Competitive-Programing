## 二、数据结构定义与分析

本次实验中定义了以下三个数据结构：

- `stack<char> num` 操作数栈，用于存储参与运算的数据
- `stack<char> op` 运算符栈，用于存储运算符
- ` map<char, int> prec` 运算符优先级表，用于维护三种运算符的优先级

本次实验中定义了以下几个变量：

- `string s` 输入的字符串
- `int cnt`  当前输出的表达式编号
- `char ch ` 字符串中的字符
- `char oper` 运算符

本次实验中定义了以下几个 `lamba` 表达式

- `auto calc = [&](char a, char b, char op) -> char {}` 对`a`和`b`进行`op`双目运算

- `auto calc_not = [&](char a) -> char {}` 对`a`进行单目的取反运算

## 三、算法分析

阅读题面发现是一个与字符串与运算符有关的大模拟题目。关于运算符和优先级，较为常见的方法是用栈进行模拟，转换为后缀表达式进行维护。

首先考虑运算符的类型，题面中运算符有`! & | ( )` 五种，其中 `! & |` 用于对操作数进行逻辑运算，而 `( )` 用于改表达式的运算优先级。

运用分类讨论的思想，我们可以对这五种运算符进行分类讨论。

首先是 `! & |` 运算符，可以大致分为两类。其中 `!` 为单目运算符，只对单个数进行操作。而`& | `为双目运算符，对两个数进行运算后得出一个值。

其次是 `( )`。其中 `(` 决定了一个表达式的开始，`)` 决定了一个表达式的结束。因此，可以通过判断`( )`，结合栈模拟进行表达式的运算。

接下来需要考虑运算顺序如何实现，也就是如何模拟一个正确的运算符优先级系统和括号系统。

首先我们可以用一个 `map` 维护三种运算符的优先级。

其次，我们注意到优先级高的运算符需要先于优先级低的运算符计算。也就是说在一个表达式中，我们可以一直按照一个方法进行运算，直到遇到优先级低于该表达式的运算符，再停止运算。

再结合左右括号判断进行模拟即可。为了模拟方便，我们可以去掉输入字符串末尾的等号，并在字符串头尾分别加入`(`和`)`方便模拟。

## 四、 算法的时间复杂度分析

阅读代码，每个字符只被运算一次时间复杂度`O(n)`，`stack.push()` 和 `stack.pop()` 的时间复杂度均为`O(1)`，表达式运算的操作时间复杂度为`O(1)`，固定大小的`map`的查询时间复杂度为`O(1)`。

总时间复杂为`O(n)`，其中 `n` 是输入的字符串的长度。

## 五、测试用例的选择原因以及测试结果

### 1. 样例测试

**输入1：**

```in
!(t&f|f)=
```

**预期输出1：**

```
1:t & f = f
2:f | f = f
3:! f = t
result = t
```

**实际输出1：**



**输入2：**

```in
!(t&f|f)=
```

**预期输出2：**

```
1:t | f = t
2:t | f = t
3:! t = f
result = f
```

**实际输出2：**



**输入3：**

```in
!(t&f|f)=
```

**预期输出3：**

```
1:! f = t
2:t & t = t
3:! t = f
4:t | f = t
5:! t = f
6:! f = t
result = t
```

**实际输出3：**



### 2. 单目连续嵌套

**输入：**

```in
!!!t=
```

**预期输出：**

```
1:! t = f
2:! f = t
3:! t = f
result = f
```

**实际输出：**



### 3. 运算优先级验证

**输入：**

```in
!t&f=
```

**预期输出：**

```
1:! t = f
2:f & f = f
result = f
```

**实际输出：**



### 4. 复杂表达式

**输入：**

```in
!((t|f)&(f|!f))=
```

**预期输出：**

```
1:t | f = t
2:! f = t
3:f | t = t
4:t & t = t
5:! t = f
result = f
```

**实际输出：**



## 六、存在问题及可能原因

1. **表达式运算顺序不正确**
   - **问题**：表达式运算顺序不正确
   - **原因**：可能是运算符优先级表没有正确维护或者括号表达式没有正确处理导致的
2. **运算结果不正确**
   - **问题**：表达式运算结果不正确
   - **原因**：可能是运算过程逻辑不正确导致的
3. **格式错误**
   - **问题**：输出格式错误
   - **原因**：可能是行尾空格等等原因导致的

## 七、附源代码以及代码相应注释

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin >> s;

    // 删除字符串末尾等于号
    s.pop_back();

    // num 栈, 用于记录参与运算的数据
    stack<char> num;
    // op 栈，用于记录运算符
    stack<char> op;

    // 当前输出的表达式编号
    int cnt = 0;

    // 双目运算
    auto calc = [&](char a, char b, char op) {
        // 将字符转换为布尔值
        bool x = (a == 't'), y = (b == 't');
        // 判断运算类型并进行运算
        char res = (op == '&') ? (x && y ? 't' : 'f') : (x || y ? 't' : 'f');
        // 按题目要求构造输出
        cnt++;
        cout << cnt << ":" << a << " " << op << " " << b << " = " << res << "\n";
        // 返回结果
        return res;
    };

    // 单目运算
    auto calc_not = [&](char a) {
        // 非运算，将字符取反
        char res = (a == 't') ? 'f' : 't';
        // 按题目要求构造输出
        cnt++;
        cout << cnt << ":! " << a << " = " << res << "\n";
        // 返回结果
        return res;
    };

    // 运算符优先级表
    map<char, int> prec = {
        {'!', 3},
        {'&', 2},
        {'|', 1}
    };

    // 字符串前后加入哨兵括号方便处理
    s.insert(s.begin(), '(');
    s.push_back(')');

    for (char ch : s) {
        // 当前如果是运算值直接入运算值栈存储
        if (ch == 't' || ch == 'f') {
            num.push(ch);
            continue;
        }

        // 如果是左括号直接入运算符栈不需要处理逻辑
        if (ch == '(') {
            op.push(ch);
            continue;
        } 

        // 如果是运算符用栈进行模拟计算
        if (ch == '!' || ch == '&' || ch == '|') {
            // 如果不是 ! 需要判断运算符优先级
            // 高于当前运算符优先级的运算符需要先计算
            // 因此运算到优先级低于当前运算符优先级的运算符然后就可以 break
            while (ch != '!' && prec[op.top()] >= prec[ch]) {
                // 如果是右括号说明括号前的运算已经完成直接 break
                if(op.top() == '(') {
                    break;
                }
                
                // 取出操作符
                char oper = op.top(); 
                op.pop();

                // 如果是 ! 那么进行单目运算
                if (oper == '!') {
                    // 取出操作数
                    char a = num.top(); 
                    num.pop();
                    // 运算后推入操作数栈
                    num.push(calc_not(a));
                    continue;
                } 

                // 如果是 & 或者 | 进行双目运算
                if (oper == '&' || oper == '|'){
                    // 取出操作数
                    char b = num.top(); 
                    num.pop();
                    char a = num.top(); 
                    num.pop();
                    // 运算后推入操作数栈
                    num.push(calc(a, b, oper));
                    continue;
                }
            }

            // 推入当前操作符
            op.push(ch);
            continue;
        } 

        // 如果是右括号需要将上一个左括号前的表达式求值
        if (ch == ')') {
            // 栈空或者遇到左括号就停止循环
            while (op.top() != '(') {
                // 取出操作符
                char oper = op.top(); 
                op.pop();

                // 如果是 ! 那么进行单目运算
                if (oper == '!') {
                    // 取出操作数
                    char a = num.top(); 
                    num.pop();
                    // 运算后推入操作数栈
                    num.push(calc_not(a));
                    continue;
                } 

                // 如果是 & 或者 | 进行双目运算
                if (oper == '&' || oper == '|'){
                    // 取出操作数
                    char b = num.top(); 
                    num.pop();
                    char a = num.top(); 
                    num.pop();
                    // 运算后推入操作数栈
                    num.push(calc(a, b, oper));
                    continue;
                }
            }
            // 将右括号 ( 出栈
            op.pop();
            continue;
        }
    }

    cout << "result = " << num.top();
    return 0;
}
```



## 八、实验创新点或合理化建议

本次实验是一个经典的运算表达式求值问题，是栈这一数据结构的经典运用。除了栈的运用之外，也考察选手的代码功底于模拟能力，以及对代码的调试于查错能力。在实现模拟题目时，往往需要理清模拟思路，甚至把简要思路写下来梳理。模拟题目的题意简单，主要就是在考察选手的代码能力以及耐心于细心程度。总而言之，对于此类模拟题，需要勤加联练习，打好扎实的代码功底。

 