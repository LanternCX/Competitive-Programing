## 一、实验题目

## 二、数据结构定义

- col: 一维线性表，大小 `n` 用于标记行是否放置棋子

```c++
vector<int> col(n, 0);
```

- diag: 二维线性表，大小 `2 * (2 * n)`，用于标记主、副对角线是否放置棋子

```c++
vector<vector<int>> diag(2, vector<int>(n * 2, 0));
```

## 三、算法分析

首先观察到数据范围 `n <= 10`，因此我们可以考虑采用暴力枚举的方法枚举所有答案，对枚举得到的每个合法方案累加计数得到最终答案，因此可以得到解题的大致思路。

再观察题目，我们可以发现几条性质：

1. 判断坐标为 `(x, y)` 的棋盘格子是否能放置棋子，其实就是需要判断第 `x` 行，第  `y` 列，以及所处的两条对角线是否存在别的棋子
2. 每一行有且仅有一个位置可以放置棋子
3. 坐标为 `(x, y)` 的棋盘格子所处的两条对角线编（0下标）为 `x + y` 和 `n - i + row`

从这三条性质，我们可以得到最终的思路：

从第一行向最后一行进行搜索，对于第 `i` 行我们遍历该行的每一个单元格，判断当前格是否可以放置。若可以放置，则继续搜索第 `i + 1` 行，直到 `n` 行全部被放置棋子，我们就搜索得到了一个合法的方案。

而这个过程，使用基于递归的 `dfs` 在过程中使用回溯维护行以及两条对角线的被占用情况，就可以在 $ O(1) $ 的复杂度内判断当前格是否被占用。

核心代码如下：

```c++
auto dfs = [&](auto&& dfs, int row) -> void {
    //  统计答案
    if (row == n) {
        ans += 1;
        return;
    }

    // 对于当前行逐列枚举搜索可放位置
    for (int i = 0; i < n; i++) {
        // 第 row 行 第 i 列 对应 第 n - i + row 条主对角线与 第 i + row 条副对角线
        if (!col[i] && !diag[0][i + row] && !diag[1][n - i + row]) {
            // 对列、主对角线、副对角线标记访问
            col[i] = 1;
            diag[0][i + row] = 1;
            diag[1][n - i + row] = 1;

            dfs(dfs, row + 1);

            // 回溯
            col[i] = 0;
            diag[0][i + row] = 0;
            diag[1][n - i + row] = 0;
        }
    }
};
```

## 四、算法的复杂度

由于每行每列只能出现一个棋子，因此可以看作是对一个长度为 `n` 的数组求全排列的情况个数。

因此时间复杂度为 $ O(n!) $

但是由于我们在搜索过程中使用了剪枝，实际复杂度应低于 $ O(n!) $

## 五、测试运行结果



## 六、存在问题及可能原因

1. **时间复杂度为指数级，扩展性较差**

该算法本质上仍是基于回溯的全排列搜索，时间复杂度为 O(n!)O(n!)O(n!)。虽然通过列和对角线剪枝减少了搜索分支，但当 `n` 增大时，搜索规模仍会迅速增长，仅适用于题目给定的较小数据范围。

2. **未利用对称性进行进一步剪枝**

N 皇后问题存在左右翻转等对称解，本算法会对这些对称方案重复搜索，造成一定的冗余计算，搜索效率仍有提升空间。

3. **实现方式存在一定常数开销**

程序使用 `vector` 维护列和对角线的占用状态，逻辑清晰但效率并非最优。相比使用位运算或静态数组，在性能上存在一定的常数级开销。

## 七、附源代码以及代码相应注释

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void sol() {
    int n;
    cin >> n;
    
    // 用于标记行是否放置棋子
    vector<int> col(n, 0);
    // 用于标记主副对角线是否放置棋子
    vector<vector<int>> diag(2, vector<int>(n * 2, 0));
    
    // 答案可能很大因此开 long long 防溢出
    ll ans = 0;
    // dfs 搜索放到第 row 行的时候接下来可放的位置
    auto dfs = [&](auto&& dfs, int row) -> void {
        //  统计答案
        if (row == n) {
            ans += 1;
            return;
        }

        // 对于当前行逐列枚举搜索可放位置
        for (int i = 0; i < n; i++) {
            // 第 row 行 第 i 列 对应 第 n - i + row 条主对角线与 第 i + row 条副对角线
            if (!col[i] && !diag[0][i + row] && !diag[1][n - i + row]) {
                // 对列、主对角线、副对角线标记访问
                col[i] = 1;
                diag[0][i + row] = 1;
                diag[1][n - i + row] = 1;

                dfs(dfs, row + 1);

                // 回溯
                col[i] = 0;
                diag[0][i + row] = 0;
                diag[1][n - i + row] = 0;
            }
        }
    };

    // 从第 0 行开始搜索
    dfs(dfs, 0);
    
    cout << ans << '\n';
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        sol();
    }
    return 0;
}
```